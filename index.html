<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Token Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/js-base64@3.7.2/base64.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.5.25/jsrsasign-all-min.js"></script>
    <style>
        /* [Previous CSS remains exactly the same] */
    </style>
</head>
<body>
    <div class="container">
        <h1>JWT Token Editor</h1>
        
        <div class="section">
            <h2>Decode Token</h2>
            <textarea id="jwtToken" rows="3" placeholder="Paste your JWT token here">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEwNjZhOTM3LTBkNDEtNDgxZS05ZjA2LTNjMzY1MzM0MjVmYiIsImVtYWlsIjoid29nZW1pZDg2NkBrbG91ZGlzLmNvbSIsInVzZXJUeXBlIjoiRFJJVkVSIiwiaWF0IjoxNzUzNjQzNTEyLCJleHAiOjE3NTM2NDcxMTJ9.upoPf6qUF28iCZPPfVt9hQo9BJMr2s-qMDW94r9Hfjo</textarea>
            <button onclick="decodeToken()">Decode</button>
            <div id="decodedResult"></div>
        </div>
        
        <div class="section">
            <h2>Verify Token</h2>
            <select id="verifyAlgorithm">
                <option value="HS256">HS256</option>
                <option value="HS384">HS384</option>
                <option value="HS512">HS512</option>
                <option value="RS256">RS256</option>
            </select>
            <textarea id="secretKey" rows="2" placeholder="Enter secret (for HMAC) or public key (for RSA)"></textarea>
            <button onclick="verifyToken()">Verify</button>
            <div id="verificationResult"></div>
        </div>
        
        <div class="section">
            <h2>Create Custom Token</h2>
            <div id="payloadItems">
                <!-- Payload items will be added here -->
            </div>
            <button onclick="addPayloadItem()">Add Field</button>
            <select id="algorithm">
                <option value="HS256">HS256</option>
                <option value="HS384">HS384</option>
                <option value="HS512">HS512</option>
                <option value="RS256">RS256</option>
            </select>
            <textarea id="newSecret" rows="2" placeholder="Enter secret (for HMAC) or private key (for RSA)"></textarea>
            <button onclick="generateToken()">Generate Token</button>
            <div id="generatedToken"></div>
        </div>
    </div>

    <script>
        // Initialize with example payload
        let payload = {
            id: "1066a937-0d41-481e-9f06-3c36533425fb",
            email: "wogemid866@kloudis.com",
            userType: "DRIVER",
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + 3600
        };

        // Render payload items
        function renderPayloadItems() {
            const container = document.getElementById('payloadItems');
            container.innerHTML = '';
            
            for (const [key, value] of Object.entries(payload)) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'payload-item';
                
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.value = key;
                keyInput.dataset.originalKey = key;
                
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.value = typeof value === 'object' ? JSON.stringify(value) : value;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => {
                    delete payload[key];
                    renderPayloadItems();
                };
                
                itemDiv.appendChild(keyInput);
                itemDiv.appendChild(valueInput);
                itemDiv.appendChild(deleteBtn);
                container.appendChild(itemDiv);
            }
        }

        // Add new payload item
        function addPayloadItem() {
            const newKey = `newField${Object.keys(payload).length + 1}`;
            payload[newKey] = "value";
            renderPayloadItems();
        }

        // Decode JWT token
        function decodeToken() {
            const token = document.getElementById('jwtToken').value.trim();
            const resultDiv = document.getElementById('decodedResult');
            
            try {
                const parts = token.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }
                
                const header = JSON.parse(Base64.decode(parts[0]));
                const payload = JSON.parse(Base64.decode(parts[1]));
                const signature = parts[2];
                
                // Update the payload editor and algorithm selection
                updatePayloadEditor(payload);
                document.getElementById('algorithm').value = header.alg;
                document.getElementById('verifyAlgorithm').value = header.alg;
                
                resultDiv.innerHTML = `
                    <h3>Header:</h3>
                    <pre>${JSON.stringify(header, null, 2)}</pre>
                    <h3>Payload:</h3>
                    <pre>${JSON.stringify(payload, null, 2)}</pre>
                    <h3>Signature:</h3>
                    <pre>${signature}</pre>
                `;
            } catch (error) {
                resultDiv.innerHTML = `<p class="error">Error decoding token: ${error.message}</p>`;
            }
        }

        // Update payload editor with decoded payload
        function updatePayloadEditor(newPayload) {
            payload = JSON.parse(JSON.stringify(newPayload));
            renderPayloadItems();
        }

        // Verify token with secret/key
        function verifyToken() {
            const token = document.getElementById('jwtToken').value.trim();
            const secret = document.getElementById('secretKey').value.trim();
            const algorithm = document.getElementById('verifyAlgorithm').value;
            const resultDiv = document.getElementById('verificationResult');
            
            try {
                const parts = token.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }
                
                const header = parts[0];
                const payload = parts[1];
                const signature = parts[2];
                
                let expectedSignature;
                
                if (algorithm.startsWith('HS')) {
                    // HMAC verification
                    const hashAlgo = algorithm === 'HS256' ? CryptoJS.SHA256 : 
                                    algorithm === 'HS384' ? CryptoJS.SHA384 : 
                                    CryptoJS.SHA512;
                    
                    expectedSignature = CryptoJS.HmacSHA256(header + '.' + payload, secret)
                        .toString(CryptoJS.enc.Base64)
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_')
                        .replace(/=+$/, '');
                } else if (algorithm === 'RS256') {
                    // RSA verification
                    const pubKey = KEYUTIL.getKey(secret);
                    const sig = new KJUR.crypto.Signature({alg: 'SHA256withRSA'});
                    sig.init(pubKey);
                    sig.updateString(header + '.' + payload);
                    expectedSignature = sig.sign();
                }
                
                if (signature === expectedSignature) {
                    resultDiv.innerHTML = `<p class="success">Token is valid! (Algorithm: ${algorithm})</p>`;
                } else {
                    resultDiv.innerHTML = `<p class="error">Token verification failed. Signature doesn't match.</p>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<p class="error">Error verifying token: ${error.message}</p>`;
            }
        }

        // Generate new token
        function generateToken() {
            const secret = document.getElementById('newSecret').value.trim();
            const algorithm = document.getElementById('algorithm').value;
            const resultDiv = document.getElementById('generatedToken');
            
            try {
                // Update payload from editor
                updatePayloadFromEditor();
                
                // Create header
                const header = {
                    alg: algorithm,
                    typ: "JWT"
                };
                
                const encodedHeader = Base64.encode(JSON.stringify(header)).replace(/=+$/, '');
                const encodedPayload = Base64.encode(JSON.stringify(payload)).replace(/=+$/, '');
                
                let signature;
                
                if (algorithm.startsWith('HS')) {
                    // HMAC signing
                    const hashAlgo = algorithm === 'HS256' ? CryptoJS.SHA256 : 
                                    algorithm === 'HS384' ? CryptoJS.SHA384 : 
                                    CryptoJS.SHA512;
                    
                    signature = CryptoJS.HmacSHA256(encodedHeader + '.' + encodedPayload, secret)
                        .toString(CryptoJS.enc.Base64)
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_')
                        .replace(/=+$/, '');
                } else if (algorithm === 'RS256') {
                    // RSA signing
                    const prvKey = KEYUTIL.getKey(secret);
                    const sig = new KJUR.crypto.Signature({alg: 'SHA256withRSA'});
                    sig.init(prvKey);
                    sig.updateString(encodedHeader + '.' + encodedPayload);
                    signature = hextob64u(sig.sign());
                }
                
                const newToken = `${encodedHeader}.${encodedPayload}.${signature}`;
                
                resultDiv.innerHTML = `
                    <h3>Your new JWT token (${algorithm}):</h3>
                    <textarea rows="3" style="width:100%">${newToken}</textarea>
                    <button onclick="copyToClipboard('${newToken}')">Copy to Clipboard</button>
                `;
            } catch (error) {
                resultDiv.innerHTML = `<p class="error">Error generating token: ${error.message}</p>`;
            }
        }

        // [Rest of the code remains the same...]
    </script>
</body>
</html>
